3.1 Общее определение и информация о строковом типе
Строка – тип данных, значениями которого является произвольная последовательность символов алфавита. Строковый тип является одним из наиболее полезных и часть используемых, обобщает понятие символьных массивов, позволяет динамически изменять длину строки. Каждая пере-менная данного типа может быть представлена фиксированным количе-ством байтов или иметь произвольную длину. 
Строка обычно понимается как тип данных  и часто реализуется в виде массива байтов, в котором хранится последовательность символов в некоторой кодировке. Строковый тип может обозначать другие последо-вательности типов данных и структур. 
Некоторые языки программирования накладывают ограничения на максимальную длину строки, однако в большинстве языков подобные ограничения отсутствуют. При использовании Unicode каждый символ строкового типа может требовать двух или даже четырёх байтов для свое-го представления. В определенных кодировках один символ может зани-мать более одной записи в массиве.  Как пример, UTF-8, где отдельные ко-ды могут занимать от одного до четырех байтов, а отдельные символы мо-гут занимать произвольное количество кодов. В этих случаях логическая длина строки (количество символов) отличается от физической длины мас-сива (количество используемых байтов).

3.2 Представление строковых структура в памяти 
Для представления строк в машинной памяти важен выбор набора символов и метод их кодирования. Более старые реализации строк были разработаны для работы с кодировкой ASCII или более поздними расши-рениями, такими как серия ISO 8859. Современные реализации часто при-бегают к использованию Unicode, наряду с множеством сложных кодиро-вок, таких как UTF-8 и UTF-16.
К основным проблемам машинного представления строкового типа относят:
- возможность иметь существенный размер;
- изменяемая длина строки.
В представлении строк в памяти компьютера существует два прин-ципиально разных подхода.

3.2.1 Метод Pascal strings
Особенностью этого подхода является представление строки как мас-сива символов с использованием некоторой кодировки. Размер последова-тельности храниться в отдельной служебной области. Впервые этот подход был реализован в языке программирования Pascal, откуда и получил своё название Pascal strings. Несколько оптимизированной разновидностью данного метода является формат c-addr, применяемый в языке программи-рования Форт. В отличие от Pascal strings, здесь размер массива хранится не совместно со строковыми данными, а является частью указателя на строку.
- Преимуществами данного метода являются:
- Хранение информации о размере массива, что позволяет выпол-нять операции добавления, копирования и получения размера достаточно быстро; 
- Строк может содержать произвольный набор данных;
- Возможность на программном уровне следить за выходом за границы строки при её обработке;
- Быстрое выполнение операции взятия N-го символа строки.
К недостаткам метода относят: 
- Проблемы с хранением и обработкой символов произвольной длины;
- Увеличение затрат на хранение строки, за счёт дополнительного значения размера массива;
- Ограничение максимального размера строки;
- При использовании алфавита с переменным размером символа (например, UTF-8), в размере хранится не количество символов, а именно размер строки в байтах, поэтому количество символов необходимо счи-тать отдельно.

3.2.2 Метод «завершающего байта»
Особенность данного метода является использование символа с кодом 0 для обозначения конца строки. Строковая структура в этом подходе хранится как последовательность байтов от начала до конца. Есть системы, в которых в качестве признака конца строки используется не символ 0, а байт 0xFF (255) или код символа «$».
Метод имеет три названия: ASCIIZ, C-strings, и метод нуль-терминированных строк.
Наибольшее распространение метод получил в языке Си, где и полу-чил название C-strings.
Преимущества данного метода:
- Возможность представления строки без создания отдельного типа данных;
- Отсутствие ограничения на максимальный размер строки;
- Экономное использование памяти;
- Простота получения суффикса строки;
- Простота передачи строк в функцию в виде аргумента.
- Возможность использования кодировок с переменным размером символа (например UTF-8);
Недостатками данного метода являются:
- долгое выполнение операций получения длины и конкатенации строк;
- отсутствие средств контроля за выходом за пределы строки, в случае повреждения завершающего байта возможность повреждения больших областей памяти;
- невозможность использовать символ завершающего байта в каче-стве элемента строки;
3.2 Поиск подстроки в строке
Со строками можно проводить следующие операции:
- Простейшие операции (получение символа по номеру позиции, конкатенация);
- Производные операции (поиск подстроки в строке, получение подстроки по индексам начала и конца, проверка на совпадение, получе-ние длины строки и т.д.);
- Сложные операции (нахождение минимальной надстроки, содер-жащей все указанные строки, поиск в двух массивах строк совпадающих последовательностей).
- Одной из самых распространённых операций над строковыми струк-турами является поиск подстроки в строке. Эта задача часто возникает при разработке поисковых программ, редакторов текстовых документов, баз данных, программ индексации страниц и тому подобное. В зависимости от области применения решения могут отличаться. 

3.3 Алгоритмы поиска подстроки
3.3.1 Алгоритм прямого поиска подстроки в строке
Графически суть данного алгоритма можно интерпретировать как скольжение «шаблона» с подстрокой по строке в процессе которого отме-чается, для каких сдвигов все символы шаблона равны соответствующим символам текста. На рисунке 3.1 изображён принцип работы данного ал-горитма. Шаблон последовательно прикладывает к строке смещаясь с каждой итерацией на один символ пока не будет найдено соответствие.
Время работы прямого поиска в худшем случае равно O((n-m+1)m), где n – длина исходной строки, а m – длина искомого шаблона. Алгоритм не имеет предварительной обработки поэтому время работы равно време-ни сравнения. 
Алгоритм прямого поиска работает довольно быстро при сравнении небольших строк, но, если строки будут иметь внушительную длину, он будет работать очень медленно. Явных недостатками поиска являются большое количество лишних сравнений и игнорирование информации по-лученной при сравнении символов, для последующих сравнений. 

3.3.2 Алгоритм Рабина-Карпа
Данный алгоритм был предложен в 1987 года М. Рабином и Р. Кар-пом. Суть метода заключается использовании функций хеширования для поиска подстрок. Алгоритм редко используется для поиска одиночного шаблона, но очень эффективен в поиске совпадений множественных шаб-лонов одинаковой длины.
Для текста длины n и шаблона длины m его среднее и лучшее время исполнения равно O(n) при правильном выборе хеш-функции, но в худ-шем случае он имеет эффективность O((n-m+1)m), что является одной из причин того, почему он не слишком широко используется. Время предва-рительной обработки в алгоритме составляет O(m). Для приложений, в ко-торых допустимы ложные срабатывания при поиске, то есть, когда неко-торые из найденных вхождений шаблона на самом деле могут не соответ-ствовать шаблону, алгоритм Рабина — Карпа работает за гарантирован-ное время O(n) и при подходящем выборе рандомизированной хеш-функции вероятность ошибки можно сделать очень малой. Также алгоритм имеет уникальную особенность находить любую из заданных k строк оди-наковой длины в среднем  за время O(n) независимо от размера k.
Одно из простейших практических применений алгоритма состоит в определении плагиата. 
Алгоритм поиска Рабина-Карпа хорошо работает во многих практических случаях, но совершенно неэффективен, например, на поиске строки из 10 тысяч символов «a», за которыми следует «b», в строке из 10 милли-онов символов «a». В этом случае он показывает своё худшее время ис-полнения O((n-m+1)m).
Алгоритм использует тот факт, что если две строки одинаковы, то и их хеш-значения также одинаковы. Однако существует две проблемы: по-явление коллизий при хешировании, циклический пересчёт хеша. 
Решением первой проблемы является посимвольное сравнение под-строк при равенстве хеша. Однако это занимает достаточно много време-ни, если данные подстроки имеют большую длину. При использовании хороших хеш-функций коллизии случаются крайне редко, что не даёт зна-чительно вырасти значению среднего времени поиска. 
Решением второй проблемы является использовании так называемо-го кольцевого хеша. Самым простым примером кольцевого хеша является добавление значений каждого следующего символа в подстроке и после-дующее использование данной формулы для подсчёта каждого следующе-го хеш-значения за фиксированное время: s[i+1..i+m] = s[i..i+m-1] - s[i] + s[i+m]. 
Каждый сим-вол здесь представлен десятичной цифрой, а вычисления хеша произво-дятся по модулю 13. В части а приведена исходная строка. Из подстроки, выделенной серым цветом, получают значение хеша. В части б изображена та же текстовая строка, в которой для всех возможных 5-символьных под-строк вычислены соответствующие им значения по модулю 13. 
Найдены две подстроки с одинаковым значение хеша. В части в по-казано, как в течение фиксированного времени вычислить значение, соот-ветствующее данной подстроке, по значению предыдущей подстроки.

3.2.3 Алгоритм Бойера-Мура
В 1977 году Р. Бойер и Д. Мур разработали алгоритм общего назначения, предназначенный для поиска подстроки в строке. Преимуще-ство этого алгоритма в том, что ценой некоторого количества предвари-тельных вычислений над шаблоном (но не над строкой, в которой ведётся поиск), шаблон сравнивается с исходным текстом не во всех позициях — часть проверок пропускается как заведомо не дающая результата. 
Особенностью данного алгоритма является использование трёх эври-стик: 
- Сканирование слева направо, сравнение справа налево;
- Правило сдвига по «плохому» символу (эвристика стоп-символа);
- Правило сдвига по «хорошему» суффиксу.
Совместный эффект этих идей позволяет алгоритму проверять мень-ше, чем m+n символов и работать за линейное время O(n) в худшем слу-чае.
Для реализации правила сдвига по «плохому символу» необходимо затратить время O(m), где m – длина искомой подстроки, для формирова-ния таблицы стоп-символов. Принцип работы алгоритма проиллюстриро-ван на рисунке 3.3.
Идея данной эвристики заключается в следующем: если при сравне-нии последнего символа подстроки y с символом строки x получается несоответствие, то, зная крайнюю правую позицию символа x в подстроке, необходимо сдвинуть подстроку направо до совмещения крайнего правого x подстроки с x в основной строке. Если такого символ x в подстроке нет, то необходимо полностью сдвинуть подстроку направо за символ x. 
Это правило помогает значительно уменьшить количество сравнений и минимизировать количество операций, не дающих результата. Однако для маленьких алфавитов данное правило является не эффективным и не даёт линейного времени в худшем случае. 
Как и для правила сдвига по «плохому символу», для правила сдви-га по «хорошему» суффиксу необходимо сформировать таблицу суффик-сов для искомой подстроки. Время формирования составляет O(m), где m – длина подстроки. Идея эвристики заключается в следующем: для каждо-го возможного суффикса t подстроки s указываем наименьшую величину, на которую нужно сдвинуть её вправо, чтобы она снова совпала с t и при этом символ, предшествующий этому вхождению t, не совпадал бы с сим-волом, предшествующим суффиксу t. Если такой сдвиг невозможен, сдви-гаем подстроку на величину, равную её размеру. 
